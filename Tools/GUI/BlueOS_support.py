#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 4.23a
#  in conjunction with Tcl version 8.6
#    Jun 05, 2019 03:01:12 PM PDT  platform: Windows NT

import sys
import os

try:
    import Tkinter as tk
except ImportError:
    import tkinter as tk

try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True

try:
    import tkFileDialog as filedialog
except ImportError:
    from tkinter import filedialog

try:
    import tkMessageBox as messagebox
except ImportError:
    from tkinter import messagebox

import BlueOS_memory
from BlueOS_parsers import *
import BlueOS_task_dialog
import BlueOS_timeline
import BlueOS_tasks
import BlueOS_preferences

def import_project( file_path = None ):
    global linkfile_data, makefile_data

    cwd = os.getcwd()

    # Request the project file if one isn't specified
    if( file_path == None ):
        file_path = filedialog.askopenfilename(
                                              initialdir = os.path.split( BlueOS_preferences.preferences["cmx_proj"] )[0],
                                              title = "Select CubeMx Project",
                                              filetypes = (("CubeMx Files", "*.ioc"),
                                              ( "all files", "*.*" ))
                                              )
    if( os.path.exists( file_path )):
        proj_data = parse_CubeMx_File( file_path )

        # Test for project makefile
        return_val = True
        if( proj_data["ProjectManager"]["TargetToolchain"] != "Makefile" ):
            return_val = messagebox.askokcancel("Warning", "CubeMx project is not set to Makefile. \nProcessor data may not be found or accurate.")
            print( "Return: " + str( return_val ))

        # Read the makefile
        makefile_path = os.path.join( os.path.split( file_path )[0], "Makefile" )

        if( not os.path.isfile( makefile_path )):
            makefile_path = filedialog.askopenfilename(
                                                      initialdir = os.path.split( file_path )[0],
                                                      title = "Select CubeMx Makefile",
                                                      filetypes = ((( "all files", "*.*" )))
                                                      )

        makefile_data = parse_makefile( makefile_path )

        # Read the linker file
        linkfile_path = os.path.join( os.path.split( file_path )[0], makefile_data["LDSCRIPT"] )
        print( linkfile_path )
        if( not os.path.isfile( linkfile_path )):
            linkfile_path = filedialog.askopenfilename( initialdir = os.path.split( file_path )[0], title = "Select CubeMx Linker File", filetypes = ((( "Linker File", "*.ld" ), ( "all files", "*.*" ))))

        linkfile_data = parse_linkfile( linkfile_path )

        if( return_val == True ):
            # Format frequency string
            frequency = int( proj_data["RCC"]["SYSCLKFreq_VALUE"] )
            if( frequency >= 1000000000 ):
                freq_str = ( str( frequency/1000000000.0 ) + " Ghz" )
            elif( frequency >= 1000000 ):
                freq_str = ( str( frequency/1000000.0 ) + " Mhz" )
            elif( frequency >= 1000 ):
                freq_str = ( str( frequency/1000.0 ) + " Khz" )
            else:
                freq_str = ( str( frequency ) + " Hz" )

            # Display results
            w.Listbox1.delete( 0, "end" )
            w.Listbox1.insert( "end", "CubeMx Project: " + proj_data["ProjectManager"]["ProjectFileName"] )
            w.Listbox1.insert( "end", "CubeMx Version: " + proj_data["MxCube"]["Version"] )
            w.Listbox1.insert( "end", "CubeMx Database Version: " + proj_data["MxDb"]["Version"] )
            w.Listbox1.insert( "end", "Toolchain: " + proj_data["ProjectManager"]["TargetToolchain"] )
            w.Listbox1.insert( "end", "Board: " + proj_data["board"] )
            w.Listbox1.insert( "end", "Processor: " + proj_data["ProjectManager"]["DeviceId"] )
            w.Listbox1.insert( "end", "Frequency: " + freq_str )

            w.Listbox1.insert( "end", " " )
            for key in linkfile_data["MEMORY"]:
                w.Listbox1.insert( "end", key + ": " )
                for mem_key in linkfile_data["MEMORY"][key]:
                    w.Listbox1.insert( "end", " " + mem_key + ": " + linkfile_data["MEMORY"][key][mem_key] )

            w.Listbox1.insert( "end", " " )
            for key in linkfile_data:
                if( key != "SECTIONS" and key != "MEMORY" ):
                    if( key == "_estack" ):
                        w.Listbox1.insert( "end", "Stack Address: " + linkfile_data[key] )
                    elif( key == "_Min_Stack_Size" ):
                        w.Listbox1.insert( "end", "Minimum Stack Size: " + linkfile_data[key] )
                    elif( key == "_Min_Heap_Size" ):
                        w.Listbox1.insert( "end", "Minimum Heap Size: " + linkfile_data[key] )
                    else:
                        w.Listbox1.insert( "end", key + ": " + linkfile_data[key] )

            w.Listbox1.insert( "end", " " )
            w.Listbox1.insert( "end", "CubeMx Source Files: " )
            for source_file in makefile_data["C_SOURCES"].split( " " ):
                w.Listbox1.insert( "end", source_file )

            ram_origin = int( linkfile_data["MEMORY"]["RAM"]["ORIGIN"], 16 )
            ram_length = BlueOS_memory.mem_size_str_to_num( linkfile_data["MEMORY"]["RAM"]["LENGTH"] )
            flash_origin = int( linkfile_data["MEMORY"]["FLASH"]["ORIGIN"], 16 )
            flash_length = BlueOS_memory.mem_size_str_to_num( linkfile_data["MEMORY"]["FLASH"]["LENGTH"] )

            # Convert the length of ram from a string to a number
            ram_block.mem_start =  ram_origin
            # Convert the length of flash from a string to a number
            flash_block.mem_start = flash_origin

            # Calculate RAM end address
            ram_block.mem_end = ram_origin + ram_length

            # Calculate FLASH end address
            flash_block.mem_end = flash_origin + flash_length

            # Add the stack to RAM allocation
            stack_size = int( linkfile_data["_Min_Stack_Size"], 16 )
            stack_address = int( linkfile_data["_estack"], 16 )
            ram_block.add_item( "Stack", stack_address - stack_size, stack_size )
            ram_block.update()

            # Add the vector table to FLASH allocation
            flash_block.add_item( "Vector Table", flash_origin, BlueOS_memory.mem_size_str_to_num( "16K" ))
            flash_block.update()

    print('BlueOS_support.import_project')
    sys.stdout.flush()

def load():
    print('BlueOS_support.load')
    sys.stdout.flush()

def project_settings():
    print('BlueOS_support.project_settings')
    sys.stdout.flush()

def resize_check(p1):
    ram_block.update()
    flash_block.update()
    print('BlueOS_support.resize_check')
    sys.stdout.flush()

def T_Close( output ):
    name = list(output)[0]
    tasks.add_task( name, output[name] )

    print( "Output: " + str( output ))
    sys.stdout.flush()

def C1_Button1(p1):
    Tbox = BlueOS_task_dialog.Mbox
    Tbox.root = root
    Tbox( 'Name?', T_Close )

    print( 'BlueOS_support.C1_Button' )
    sys.stdout.flush()

def C2_Button1(p1):
    print( 'BlueOS_support.C2_Button' )
    sys.stdout.flush()

def C3_Button1(p1):
    print( 'BlueOS_support.C3_Button' )
    sys.stdout.flush()

def save():
    print( 'BlueOS_support.save' )
    sys.stdout.flush()

def init(top, gui, *args, **kwargs):
    global w, top_level, root, flash_block, ram_block, tasks

    w = gui
    top_level = top
    root = top

    ram_canvas = w.Canvas3
    ram_allocations = []

    flash_canvas = w.Canvas2
    flash_allocations = []

    flash_canvas.update()
    ram_canvas.update()

    # Set scrolling origin
    w.Canvas2.scan_mark( 0, 0 )
    w.Canvas3.scan_mark( 0, 0 )


    flash_block = BlueOS_memory.Mem_Block( flash_canvas, "FLASH" )

    ram_block = BlueOS_memory.Mem_Block( ram_canvas, "RAM" )

    tasks = BlueOS_tasks.Tasks( w.Canvas1 )

    BlueOS_preferences.load_preferences()
    print( "Preferences: " + str( BlueOS_preferences.preferences ))

    # Bind "Configure" event for resize checking
    top.bind( '<Configure>',lambda e:resize_check( e ))

if __name__ == '__main__':
    import BlueOS

    BlueOS.vp_start_gui()




